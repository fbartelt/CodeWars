import re
class RSUProgram:
    def __init__(self, source):
        self.source = source
    def get_tokens(self):
        clean_source = self.tidy_up()
        full_token = ''
        token_list = []
        for token in clean_source:
            if token.isdigit():
                full_token += token
            else:
                if full_token:
                    token_list.append(full_token)
                    full_token = token
                else:
                    full_token += token
        token_list.append(full_token)
        print(token_list)
        self.tokens = token_list
        return token_list
    def tidy_up(self):
        # se nao tiver funcionando: (?:^|\n) isso no começo talvez resolva
        bad_comment = re.search(r'((?:\)|[pFLRP])[0-9]*((\/\*.*\n*.*\*\/)+|\/\/.*\n*)[0-9]+)+', self.source)
        if bad_comment:
            raise SystemError('Invalid comment within token in => '+ bad_comment[0])
        no_comments = re.sub(r'(\/\*(?:\n|.)*?\*\/)|(?:(\/\/.*)(?:\n|$))', '', self.source)
        space_token_err = re.search(r'((?:\)|[pFLRP])\s+[0-9]+)+|([a-or-zA-EG-KM-OQS-Z])', no_comments)
        if space_token_err:
            raise SyntaxError('Invalid Tokens or whitespace within tokens in => '+ space_token_err[0])
        no_space = re.sub(r'\s+', '',no_comments)
        pattern_zeros_err = re.search(r'(p|P)([^0-9]|$)|([FRLPp)]0[0-9]+)', no_space)
        if pattern_zeros_err:
            raise SyntaxError('Leading zeros or non-identified pattern in => ' + pattern_zeros_err[0])
        print(no_space)
        return no_space
        
    def convert_to_raw(self, tokens):
        """
        TODO: Process the array of tokens generated by the `getTokens`
        method (passed into this method as `tokens`) and return an (new)
        array containing only the raw commands `F`, `L` and/or `R`
        Throw a suitable error if necessary
        """
        #### TA DANDO ERRADO PRA PATTERN DENTRO DE PATTERN. POE NO DICT ERRADO. POSSIVEL SOLUÇÃO:
        ####    LISTA DE LABELS, AO INVES DE VARIAVEL
        #### NA HORA DO CALL (P), É POSSÍVEL NA VERDADE CHAMAR UMA FUNÇÃO(p) AINDA NAO DEFINIDA
        #### FALTA IMPLEMENTAR PARADA DE RECURSAO
        raw = []
        patterns = {}
        scope = [patterns]
        commands_stack = []
        post_operations = 0
        for token in tokens:
            print('patterns', patterns)
            print('stack', commands_stack)
            print('scope', scope)
            print(post_operations)
            print('raw', raw)
            if 'p' in token:
                label = token[1:]
                if label in scope[-1].keys():
                    raise SyntaxError('Pattern ' + token + ' already definided in current scope')
                scope[-1].update({label: {}})
                scope.append(scope[-1][label])
                commands_stack.append(token)
                post_operations += 1
            #na hora do 'q' talvez dê pra dar o scope[-1].uptade({label: comands})
            elif token == 'q':
                if len(scope) <= 1:
                    raise SyntaxError('Number of patterns defined does not match with number of endings')
                cmd = commands_stack.pop()
                pattern_definition = []
                while 'p' not in cmd:
                    pattern_definition.append(cmd)
                    cmd = commands_stack.pop()
                scope.pop()
                ### TIREI O [::-1] DO PATTERN_DEFIINITION PRA TENTAR DESINVETER
                scope[-1].update({label : ''.join(pattern_definition[::-1])})
                post_operations -= 1
            #######
            # k = list(dict(x) for x in b)
            ####### jeito certo pra copiar o scope sem ficar mudando
            elif 'P' in token:
                print('cheguei')
                label_ = token[1:]
                popped = 0
                if any('p' in c for c in commands_stack):
                    popped = 1
                    aux = scope.pop()
                if label_ not in scope[-1].keys():
                    raise NameError('Trying to call "'+ token+ '" but pattern "p' + label_ + '" was not defined in this scope')
                elif post_operations:
                    print('aqui')
                    ## TIREI O [::-1] DO FINAL DO ARGUMENTO DOS DOIS APPENDS ABAIXO
                    commands_stack.append(scope[-1][label_])
                else:
                    raw.append(scope[-1][label_])
                if popped:
                    scope.append(aux)
            elif token == '(':
                commands_stack.append(token)
                post_operations += 1
            elif ')' in token:
                multiplier = int(token[1:]) if token[1:] else 1
                cmd = commands_stack.pop()
                cmd_sequence = []
                while cmd != '(':
                    if any(c in ['p','q'] for c in cmd):
                        raise SyntaxError('Nesting pattern definitions within bracketed sequences => '+cmd)
                    cmd_sequence.append(cmd)
                    cmd = commands_stack.pop()
                post_operations -= 1
                if post_operations:
                    ### TIREI O [::-1] DO CMD_SEQUENCE PRA TENTAR DESINVETER
                    commands_stack.append(''.join(cmd_sequence[::-1])*multiplier)
                else:
                    raw.append(''.join(cmd_sequence[::-1])*multiplier)
            else:
                multiplier = token[1:]
                cmd = token[0] * int(multiplier) if multiplier else token
                if post_operations:
                    commands_stack.append(cmd)
                else:
                    raw.append(cmd)
        if post_operations !=0:
            raise SyntaxError('Unmatching parenthesis or pattern definitions/ending')
        print(scope, post_operations)
        print(''.join(raw))
        return ''.join(raw)
        
    def execute_raw(self, cmds):
        """
        TODO: Execute the raw commands passed in and return a string
        representation of the MyRobot's path
        """
        pass
    def execute(self):
        """
        TODO: Work your magic here to pass the Kata :D
        """
        pass

#test = RSUProgram('/*some nosense here and there*//**/ /*hehye*/p0\n  (\n    F2L\n  )2 (\n    F2 R\n  )2\nq\n//HELLO FUCKERS\n(\n  P0\n)2')
#test = RSUProgram('p3\n  RR(\n    F4 L\n  )4\nq\n\nP3(FL)2RRF')
test = RSUProgram('p0(RR)2qp1LLLP0qp3FFFFP1qP3')
#test = RSUProgram('p0RRqp1P0q')
a = test.get_tokens()
print(test.tokens)
test.convert_to_raw(a)
#test.tidy_up()

## ['p0', '(', 'F2', 'L', ')2', '(', 'F2', 'R', ')2', 'q', '(', 'P0', ')2']
## ['p3', 'R', 'R', '(', 'F4', 'L', ')4', 'q', 'P3', '(', 'F', 'L', ')2', 'R', 'R', 'F']



### old func when token 'p'
""" elif 'P' in token:
                print('cheguei')
                label_ = token[1:]
                popped = 0
                if any('p' in c for c in commands_stack):
                    popped = 1
                    aux = scope.pop()
                if label_ not in scope[-1].keys():
                    raise NameError('Trying to call "'+ token+ '" but pattern "p' + label_ + '" was not defined in this scope')
                elif post_operations:
                    print('aqui')
                    ## TIREI O [::-1] DO FINAL DO ARGUMENTO DOS DOIS APPENDS ABAIXO
                    commands_stack.append(scope[-1][label_])
                else:
                    raw.append(scope[-1][label_])
                if popped:
                    scope.append(aux) """